# 投影矩阵

不知道大家有没有觉得[盒子](/7-box.md)章节中渲染的立方体看起来有点奇怪。我们在现实世界中看到的物体都是近大远小，但是我们没有做透视处理立方体远近都一样大导致看起来有点奇怪。我们这篇文章来学习两种投影方法，分别是正交投影和透视投影。其中透视投影就可以让立方体有近大远小的透视效果。

## 正交投影

我们先从比较简单的正交投影开始。投影是降维操作，我们要将三维物体投影到一个平面上（也就是我们的显示器）。最简单的方法就是丢弃 Z 轴，例如我们有个三维点 `[1, 1, 1]` 我们直接丢弃它的 Z 值变成 `[1, 1]`。

我们之前好像也是这样做的 Z 值只是用在深度测试，用来判断哪个点在前哪个点在后，物体的 X 和 Y 不变直接投影到屏幕上，无论距离有多远，物体在屏幕上看起来都是相同的大小。

![image](https://user-images.githubusercontent.com/25923128/122424343-38972780-cfc1-11eb-8c27-84e6a45c5afb.png)

正交投影也叫平行投影，它的特点是远近一样大，平行线可以保持平行。这也是三维图形投影到二维平面的最简单的方法，我们也可以非常轻松的写出正交投影矩阵。

```js
[
  1, 0, 0, 0,
  0, 1, 0, 0,
  0, 0, 0, 0,
  0, 0, 0, 1
]
```

上方矩阵可以将物体投影到 XY 平面上，它会保持物体的 X、Y 坐标不变将 Z 变成 0。

当然真正的投影矩阵不会这么简单，[上篇文章](/8-camera.md)提到要是能自定义裁剪空间就好了，默认情况下 OpenGL 会将 X、Y 和 Z 轴 `-1` 到 `1` 之外物体全部裁剪丢弃。我们能不能自定义裁剪空间的大小呢？这需要实现一个矩阵将一个自定义空间变到[标准化设备坐标](/2-coordinate.md)，这个就是我们要实现的正交矩阵。

假设在空间中有个盒子，我们可以通过 `top, bottom, near, far, left, right` 指定它的上下前后左右，我们可以把这个盒子进行缩放，将它的 X、Y 和 Z 缩放到 `-1` 到 `1`，再将它移动到坐标原点，这样我们就可以将这个盒子里面的所有物体变换到[标准化设备坐标](/2-coordinate.md)。

![image](https://user-images.githubusercontent.com/25923128/122438742-9cbfe880-cfcd-11eb-9029-8498756acd92.png)

首先我们来看 X 轴。

```js
class Mat4 {
  static ortho(top, bottom, near, far, left, right, out = []) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
}
```

## 透视投影
